// Symbiosis Desktop Manager
import {
  availableWidgets,
  availableApps,
  availableWidgetsOnly,
  workspaces,
  gridConfig,
  getCenterCells,
  calculateOccupiedCells,
  canWidgetFitAt,
  getWidgetById,
  categoryInfo
} from './data/widgets-static.js';

import { EventBus, EventNames } from './managers/event-bus.js';
import { StorageManager } from './managers/storage-manager.js';
import { WorkspaceManager } from './managers/workspace-manager.js';
import { WidgetManager } from './managers/widget-manager.js';
import { WidgetUIController } from './managers/widget-ui-controller.js';
import { AppUIController } from './managers/app-ui-controller.js';
import { HotkeyManager } from './managers/hotkey-manager.js';
import { DockManager } from './managers/dock-manager.js';
import { MenuBarManager } from './managers/menubar-manager.js';
import { DrawerManager } from './managers/drawer-manager.js';
import { PerformanceMonitor } from './managers/performance-monitor.js';
import { ErrorBoundary } from './managers/error-boundary.js';

// Menu bar plugins
import { LogoPlugin } from './plugins/menubar/logo-plugin.js';
import { WorkspaceSwitcherPlugin } from './plugins/menubar/workspace-switcher-plugin.js';
import { WorkspaceTitlePlugin } from './plugins/menubar/workspace-title-plugin.js';
import { SearchPlugin } from './plugins/menubar/search-plugin.js';
import { NotificationsPlugin } from './plugins/menubar/notifications-plugin.js';
import { UserMenuPlugin } from './plugins/menubar/user-menu-plugin.js';

import Sortable from 'sortablejs';

class DesktopManager {
  constructor() {
    // Initialize managers
    this.initializeManagers();

    // Subscribe to events (decoupled manager communication)
    this.setupEventListeners();

    this.init();
  }

  initializeManagers() {
    // Initialize EventBus first (for decoupled manager communication)
    this.eventBus = new EventBus();
    // this.eventBus.setDebug(true); // Uncomment for debugging

    // Initialize Error Boundary (catches and handles errors gracefully)
    this.errorBoundary = new ErrorBoundary({
      logErrors: true,
      showUI: true,
      onError: (error, context) => {
        // Log error to analytics/monitoring service here if needed
        console.error('Application Error:', error, context);
      }
    });

    // Make available globally for debugging
    window.errorBoundary = this.errorBoundary;

    // Initialize Performance Monitor (enabled in dev mode by default)
    this.perfMonitor = new PerformanceMonitor({
      enabled: true,
      slowThreshold: 100,
      autoReport: false // Set to true for auto-reports every 60s
    });

    // Make available globally for debugging
    window.perfMonitor = this.perfMonitor;

    // Initialize Storage Manager (wrapped in error boundary)
    this.storageManager = this.errorBoundary.wrapComponent(
      () => new StorageManager(),
      'StorageManager',
      document.getElementById('widget-grid')
    );

    if (!this.storageManager) {
      console.error('Failed to initialize StorageManager');
      return;
    }

    // Initialize WidgetManager with EventBus (no more callbacks!)
    this.widgetManager = new WidgetManager({
      eventBus: this.eventBus,
      storageManager: this.storageManager
    });

    // Initialize WidgetUIController with EventBus
    this.widgetUIController = new WidgetUIController({
      widgetManager: this.widgetManager,
      gridContainer: document.getElementById('widget-grid'),
      eventBus: this.eventBus
    });

    // Initialize AppUIController with EventBus
    this.appUIController = new AppUIController({
      containerElement: document.body,
      eventBus: this.eventBus
    });

    // Connect AppUIController to WidgetUIController
    this.widgetUIController.appUIController = this.appUIController;

    // Initialize WorkspaceManager with EventBus (no more callbacks!)
    this.workspaceManager = new WorkspaceManager({
      eventBus: this.eventBus,
      storageManager: this.storageManager
    });

    // Initialize HotkeyManager (new registration-based API)
    this.hotkeyManager = new HotkeyManager();

    // Set AppUIController as focus provider (enables app vs workspace routing)
    this.hotkeyManager.setFocusProvider(this.appUIController);

    // Register workspace-level hotkeys
    this.registerWorkspaceHotkeys();

    // Initialize DockManager with EventBus
    this.dockManager = new DockManager({
      storageManager: this.storageManager,
      eventBus: this.eventBus
    });

    // Initialize MenuBarManager (plugin-based menu bar)
    this.menuBarManager = new MenuBarManager({
      container: document.getElementById('top-bar'),
      userRole: 'user' // TODO: Get from actual user session
    });

    // Register all menu bar plugin classes
    this.menuBarManager.registerPluginClass('logo', LogoPlugin);
    this.menuBarManager.registerPluginClass('workspace-switcher', WorkspaceSwitcherPlugin);
    this.menuBarManager.registerPluginClass('workspace-title', WorkspaceTitlePlugin);
    this.menuBarManager.registerPluginClass('search', SearchPlugin);
    this.menuBarManager.registerPluginClass('notifications', NotificationsPlugin);
    this.menuBarManager.registerPluginClass('user-menu', UserMenuPlugin);

    // Initialize DrawerManager with EventBus
    this.drawerManager = new DrawerManager({
      eventBus: this.eventBus,
      widgetDefinitions: availableWidgets
    });

    // Setup global wrapper functions for HTML onclick handlers (backward compatibility)
    window.openWidgetDrawer = () => this.drawerManager.open();
    window.closeWidgetDrawer = () => this.drawerManager.close();

    // Setup grid drop handlers for drag-and-drop from drawer
    this.setupGridDropHandlers();
  }

  /**
   * Setup drag-and-drop handlers for grid cells
   * Allows dragging widgets from drawer directly to specific grid cells
   */
  setupGridDropHandlers() {
    const gridCells = document.querySelectorAll('.widget-cell');

    gridCells.forEach(cell => {
      // Allow drop
      cell.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy';

        // Add visual feedback
        if (!cell.classList.contains('occupied')) {
          cell.classList.add('drop-target');
        }
      });

      // Remove visual feedback when leaving
      cell.addEventListener('dragleave', (e) => {
        cell.classList.remove('drop-target');
      });

      // Handle drop
      cell.addEventListener('drop', (e) => {
        e.preventDefault();
        cell.classList.remove('drop-target');

        // Get widget data from drag event
        const widgetData = JSON.parse(e.dataTransfer.getData('text/plain'));
        const cellNumber = parseInt(cell.dataset.cell);

        // Check if widget can fit at this position
        if (this.widgetManager.canPlaceWidget(cellNumber, widgetData.cols, widgetData.rows)) {
          this.widgetManager.addWidget(widgetData, cellNumber);
          this.drawerManager.close();
        } else {
          alert(`Cannot place ${widgetData.name} here - not enough space or cells occupied`);
        }
      });
    });

    console.log('âœ… Grid drop handlers installed for drag-and-drop');
  }

  /**
   * Setup event listeners (replaces callback hell)
   * Each manager emits events, DesktopManager orchestrates responses
   */
  setupEventListeners() {
    // Performance Monitoring: Track all events
    // Create a wrapper for eventBus.emit to auto-track events
    const originalEmit = this.eventBus.emit.bind(this.eventBus);
    this.eventBus.emit = (eventName, data) => {
      this.perfMonitor.trackEvent(eventName);
      return originalEmit(eventName, data);
    };

    // Widget Events
    this.eventBus.on(EventNames.WIDGET_ADDED, (widget) => {
      // IMPORTANT: Only handle widget DEFINITIONS from drawer, not INSTANCES
      // Widget instances have an id like "instance-123456" and a widgetDefId
      // Widget definitions from drawer have a regular id like "clock", "weather", etc.
      const isInstance = widget.id && widget.id.startsWith('instance-');
      const hasInstanceFields = widget.widgetDefId && widget.userId;

      if (isInstance || hasInstanceFields) {
        // This is already a widget instance (just created by widgetManager.addWidget)
        // Just render it, don't add it again!
        console.log('Widget instance created, rendering:', widget.id);
        this.renderWidget(widget);
        this.hideWelcome();
        return;
      }

      // This is a widget DEFINITION from the drawer - create an instance
      console.log('Adding widget from drawer:', widget.id);
      const cell = this.widgetManager.findAvailableCell(widget.cols, widget.rows);
      if (cell) {
        // This will emit widget:added again with the INSTANCE, which will be caught above
        this.widgetManager.addWidget(widget, cell);
        this.hideWelcome();
      } else {
        alert(`No space available for ${widget.name} (${widget.size})`);
      }
    });

    this.eventBus.on(EventNames.WIDGET_REMOVED, (widgetId) => {
      // Widget deletion is handled by WidgetManager
      console.log('Widget deleted:', widgetId);
      if (this.widgetManager.widgets.length === 0) {
        this.showWelcome();
      }
    });

    this.eventBus.on(EventNames.WIDGET_MOVED, (data) => {
      // Re-render widget after it's moved
      this.renderWidget(data.widget);
    });

    // Workspace Events
    this.eventBus.on(EventNames.WORKSPACE_SWITCHED, (workspace) => {
      this.perfMonitor.startTimer('workspace-switch');

      // Clear grid and load widgets for new workspace
      this.widgetManager.clearGrid();
      this.widgetManager.setCurrentWorkspace(workspace.id);
      const instances = this.storageManager.getWidgetInstancesForWorkspace(workspace.id);
      this.widgetManager.setWidgets(instances || []);

      // Render widgets and show/hide welcome
      if (instances && instances.length > 0) {
        instances.forEach(widget => this.renderWidget(widget));
        this.hideWelcome();
      } else {
        this.showWelcome();
      }

      const switchTime = this.perfMonitor.endTimer('workspace-switch');
      console.log(`Switched to workspace "${workspace.name}" (${switchTime.toFixed(0)}ms)`);
    });

    // Dock Events
    this.eventBus.on(EventNames.DOCK_APP_CLICKED, (app) => {
      // Handle dock app click - open app
      this.openAppFromDock(app);
    });

    this.eventBus.on(EventNames.DOCK_WIDGET_ADDED, (widget) => {
      // Add widget to dock (from wiggle mode)
      if (this.dockManager) {
        this.dockManager.addApp({
          id: widget.widgetDefId || widget.id,
          name: widget.name,
          icon: widget.icon,
          type: 'app',
          cols: 1,
          rows: 1
        });
      }
    });

    // App Events
    this.eventBus.on(EventNames.APP_OPENED, ({ instanceId, appId }) => {
      console.log(`App opened: ${appId} (${instanceId})`);
    });

    this.eventBus.on(EventNames.APP_CLOSED, ({ instanceId, appId }) => {
      console.log(`App closed: ${appId} (${instanceId})`);
    });

    this.eventBus.on(EventNames.APP_FOCUSED, ({ instanceId, appId }) => {
      console.log(`App focused: ${instanceId}`);
    });

    // UI Events
    this.eventBus.on(EventNames.WELCOME_SHOW, () => {
      this.showWelcome();
    });

    this.eventBus.on(EventNames.WELCOME_HIDE, () => {
      this.hideWelcome();
    });

    this.eventBus.on(EventNames.GRID_CLEARED, () => {
      this.widgetManager.clearGrid();
    });
  }

  async init() {
    this.perfMonitor.startTimer('desktop-init');
    console.log('Symbiosis Desktop initializing...');

    // Load user data and update UI
    this.perfMonitor.startTimer('load-user-data');
    this.loadUserData();
    this.perfMonitor.endTimer('load-user-data');

    // Drawer is now self-contained (DrawerManager handles setup and population)

    // Load and render menu bar plugins (with user-specific config if logged in)
    this.perfMonitor.startTimer('load-menubar');
    await this.loadMenuBarConfig();
    this.perfMonitor.endTimer('load-menubar');

    // Load widgets from current workspace
    this.perfMonitor.startTimer('load-widgets');
    this.loadWidgets();
    this.perfMonitor.endTimer('load-widgets');

    // Hide welcome message if widgets exist
    if (this.widgetManager.widgets.length > 0) {
      this.hideWelcome();
    }

    // Initialize workspace UI
    this.workspaceManager.updateWorkspaceUI();

    const initTime = this.perfMonitor.endTimer('desktop-init');
    console.log(`Desktop ready! (${initTime.toFixed(0)}ms)`);
  }

  /**
   * Load menu bar configuration (user-specific or default)
   */
  async loadMenuBarConfig() {
    const user = this.storageManager.getUser();

    // STATIC MODE: Skip API calls and use static config
    // TODO: When backend is ready, set STATIC_MODE = false
    const STATIC_MODE = true;

    if (STATIC_MODE) {
      // Static mode - always use default config from static file
      console.log('ðŸ“¦ Static mode: Using default menu bar config');
      await this.menuBarManager.loadConfig();
      return;
    }

    // API MODE: Try to load user-specific config from backend
    if (user && user.id) {
      // User is logged in - try to load their custom config
      console.log(`Loading menu bar config for user ${user.id}`);
      try {
        await this.menuBarManager.loadUserConfig(user.id);
      } catch (error) {
        console.warn('Failed to load user menu bar config, using defaults:', error);
        await this.menuBarManager.loadConfig();
      }
    } else {
      // No user logged in - use default config
      console.log('No user logged in, using default menu bar config');
      await this.menuBarManager.loadConfig();
    }
  }

  // Load User Data
  loadUserData() {
    const user = this.storageManager.getUser();
    if (user) {
      const userNameElement = document.getElementById('user-name');
      const userAvatarElement = document.getElementById('user-avatar');

      if (userNameElement) {
        userNameElement.textContent = user.name;
      }

      if (userAvatarElement) {
        // Use first letter of name for avatar
        userAvatarElement.textContent = user.name.charAt(0).toUpperCase();
      }

      // TEMPORARY DEV FEATURE: Update dropdown menu
      const dropdownName = document.getElementById('user-dropdown-name');
      const dropdownAvatar = document.getElementById('user-dropdown-avatar');

      if (dropdownName) {
        dropdownName.textContent = user.name;
      }

      if (dropdownAvatar) {
        dropdownAvatar.textContent = user.name.charAt(0).toUpperCase();
      }

      console.log('User loaded:', user.name);
    }
  }

  // ========================================
  // DRAWER METHODS MOVED TO DrawerManager
  // ========================================
  // All drawer UI logic (populate, setup, open/close, drag-and-drop)
  // is now handled by DrawerManager for better separation of concerns.

  // Add Widget to Desktop (Click-to-Add)
  addWidgetToDesktop(widgetId) {
    const widgetDef = getWidgetById(widgetId);
    if (!widgetDef) {
      console.error('Widget not found:', widgetId);
      return;
    }

    // Find available position using WidgetManager
    const cellNumber = this.widgetManager.findAvailableCell(widgetDef.cols, widgetDef.rows);

    if (cellNumber === null) {
      alert(`No space available for ${widgetDef.name} (${widgetDef.size})`);
      return;
    }

    console.log(`Placing ${widgetDef.name} at cell ${cellNumber}`);

    // Create widget data
    const widgetData = {
      id: widgetDef.id,
      name: widgetDef.name,
      icon: widgetDef.icon,
      size: widgetDef.size,
      type: widgetDef.type,
      cols: widgetDef.cols,
      rows: widgetDef.rows
    };

    // Add widget using WidgetManager
    this.widgetManager.addWidget(widgetData, cellNumber);
    this.drawerManager.close();
  }

  // Render widget wrapper (for drag-drop integration)
  renderWidget(widget) {
    // Get widget definition from static data
    const widgetDefinition = getWidgetById(widget.widgetDefId || widget.appId);
    if (!widgetDefinition) {
      console.error('Widget definition not found:', widget.widgetDefId || widget.appId);
      return;
    }

    // Delegate to WidgetUIController for rendering
    this.widgetUIController.renderWidget(widget, widgetDefinition);
  }


  /**
   * Find the nearest available space for a widget that needs to be pushed aside
   * @param {Object} widget - The widget that needs to be relocated
   * @param {string} excludeWidgetId - ID of the widget being moved (to exclude from collision detection)
   * @param {Array} pendingMoves - Array of moves already planned (to avoid conflicts)
   * @returns {number|null} - Cell number for new position, or null if no space found
   */
  findNearestAvailableSpace(widget, excludeWidgetId, pendingMoves = []) {
    const widgetSize = widget.cols * widget.rows;
    const currentCell = widget.cell;
    const currentRow = Math.floor((currentCell - 1) / gridConfig.columns);
    const currentCol = (currentCell - 1) % gridConfig.columns;

    // Build a set of all occupied cells (including pending moves)
    const occupiedCells = new Set();
    this.widgetManager.widgets.forEach(w => {
      if (w.id !== excludeWidgetId && w.id !== widget.id) {
        const cells = calculateOccupiedCells(w.cell, w.cols, w.rows);
        cells.forEach(c => occupiedCells.add(c));
      }
    });

    // Add pending move destinations to occupied set
    pendingMoves.forEach(move => {
      const cells = calculateOccupiedCells(move.newCell, move.widget.cols, move.widget.rows);
      cells.forEach(c => occupiedCells.add(c));
    });

    // Search in expanding circles from current position
    // Try cells in order of distance from original position
    const candidates = [];
    for (let cell = 1; cell <= gridConfig.totalCells; cell++) {
      const row = Math.floor((cell - 1) / gridConfig.columns);
      const col = (cell - 1) % gridConfig.columns;

      // Calculate distance from original position
      const distance = Math.abs(row - currentRow) + Math.abs(col - currentCol);

      candidates.push({ cell, distance });
    }

    // Sort by distance (nearest first)
    candidates.sort((a, b) => a.distance - b.distance);

    // Try each candidate position
    for (const candidate of candidates) {
      const cell = candidate.cell;

      // Check if widget fits at this position
      if (!canWidgetFitAt(cell, widget.cols, widget.rows)) {
        continue;
      }

      // Check if all required cells are available
      const requiredCells = calculateOccupiedCells(cell, widget.cols, widget.rows);
      const isAvailable = requiredCells.every(c => !occupiedCells.has(c));

      if (isAvailable) {
        console.log(`Found space for ${widget.name} at cell ${cell} (distance: ${candidate.distance})`);
        return cell;
      }
    }

    // No space found
    console.log(`No available space found for ${widget.name}`);
    return null;
  }

  snapToTopLeftCorner(cellNumber, cols, rows) {
    // For 1Ã—1 widgets, no snapping needed
    if (cols === 1 && rows === 1) {
      return cellNumber;
    }

    // Calculate the row and column of the target cell
    const targetRow = Math.floor((cellNumber - 1) / gridConfig.columns);
    const targetCol = (cellNumber - 1) % gridConfig.columns;

    // Ensure the widget fits within grid bounds
    let snappedCol = targetCol;
    let snappedRow = targetRow;

    // Adjust if widget would overflow right edge
    if (snappedCol + cols > gridConfig.columns) {
      snappedCol = gridConfig.columns - cols;
    }

    // Adjust if widget would overflow bottom edge
    if (snappedRow + rows > gridConfig.rows) {
      snappedRow = gridConfig.rows - rows;
    }

    // Prevent negative positions
    if (snappedCol < 0 || snappedRow < 0) {
      return null;
    }

    // Convert back to cell number
    return snappedRow * gridConfig.columns + snappedCol + 1;
  }

  addWidgetStyles() {
    const style = document.createElement('style');
    style.id = 'widget-styles';
    style.textContent = `
      .widget {
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        transition: all 0.2s;
      }

      .widget:hover {
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        transform: translateY(-2px);
      }

      .widget-header {
        padding: 12px;
        border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        display: flex;
        align-items: center;
        gap: 8px;
        background: rgba(255, 255, 255, 0.5);
      }

      .widget-icon {
        font-size: 1.25rem;
      }

      .widget-title {
        flex: 1;
        font-weight: 600;
        font-size: 0.875rem;
        color: #111827;
      }

      .widget-menu-btn {
        background: none;
        border: none;
        cursor: pointer;
        font-size: 1.25rem;
        color: #6b7280;
        padding: 4px 8px;
        border-radius: 6px;
        transition: background 0.2s;
      }

      .widget-menu-btn:hover {
        background: rgba(0, 0, 0, 0.05);
      }

      .widget-body {
        flex: 1;
        padding: 12px;
        overflow: auto;
      }

      .widget-placeholder {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        color: #9ca3af;
        font-size: 0.875rem;
        text-align: center;
      }
    `;
    document.head.appendChild(style);
  }

  showWidgetMenu(widgetId) {
    const widget = this.widgetManager.getWidgetById(widgetId);
    if (!widget) return;

    // Simple context menu (to be enhanced)
    const actions = ['Move', 'Resize', 'Configure', 'Remove'];
    const action = prompt(`Widget Menu:\n${actions.join('\n')}\n\nEnter action:`);

    if (action && action.toLowerCase() === 'remove') {
      this.widgetManager.removeWidget(widgetId);
    }
  }

  // Dock Apps
  setupDockApps() {
    const apps = document.querySelectorAll('.dock-app');

    apps.forEach(app => {
      app.addEventListener('click', () => {
        const appName = app.dataset.app;
        this.openApp(appName);
      });
    });
  }

  /**
   * Open app from dock click
   * @param {Object} app - Dock app object { id, name, icon, type }
   */
  openAppFromDock(app) {
    console.log('Opening app from dock:', app);

    // Map dock app IDs to actual app definition IDs
    const dockToAppIdMap = {
      'search': 'chemicals-app',      // Map search to chemicals for now
      'ideas': 'ai-assistant-app',    // Map ideas to AI assistant
      'inventory': 'equipment-app',   // Map inventory to equipment
      'experiments': 'genetics-app',  // Map experiments to genetics
      'equipment': 'equipment-app',   // Map equipment to equipment-app
      'settings': 'notebook-app'      // Map settings to notebook for now
    };

    // Get the actual app ID (use mapping if exists, otherwise use the dock app.id directly)
    const actualAppId = dockToAppIdMap[app.id] || app.id;

    // Find app definition from availableApps
    const appDefinition = availableApps.find(a => a.id === actualAppId);

    if (!appDefinition) {
      console.error(`App definition not found for: ${app.id} (mapped to: ${actualAppId})`);
      alert(`App not found: ${app.name}\n\nDock ID: ${app.id}\nLooking for app: ${actualAppId}`);
      return;
    }

    console.log(`âœ… Launching app: ${actualAppId} (from dock item: ${app.id})`);


    // Launch app using AppUIController with app's default settings
    const instanceSettings = {
      displayMode: appDefinition.displayMode,
      animation: appDefinition.animation,
      multiInstance: appDefinition.multiInstance,
      showCloseButton: appDefinition.showCloseButton,
      showMinimizeButton: appDefinition.showMinimizeButton,
      dock: appDefinition.dock,
      menuBar: appDefinition.menuBar,
      sideNav: appDefinition.sideNav,
      dimensions: appDefinition.dimensions,
      position: appDefinition.position
    };

    this.appUIController.openApp(app.id, instanceSettings);
  }

  // Legacy method - kept for compatibility
  openApp(appName) {
    console.log('Opening app (legacy):', appName);
    // Redirect to new method
    this.openAppFromDock({ id: appName, name: appName, icon: 'ðŸ“±', type: 'system' });
  }

  // Top Bar
  setupTopBar() {
    const searchInput = document.querySelector('.topbar-search input');
    const userMenu = document.querySelector('.topbar-user');

    // Workspace dropdown is now handled via onclick in HTML

    searchInput.addEventListener('focus', () => {
      console.log('Search activated');
    });

    // TEMPORARY DEV FEATURE: User dropdown toggle
    userMenu.addEventListener('click', (e) => {
      e.stopPropagation();
      userMenu.classList.toggle('active');
    });

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (!userMenu.contains(e.target)) {
        userMenu.classList.remove('active');
      }
    });
  }

  // ============================================================
  // TEMPORARY DEV FEATURE: Memory Management (localStorage export/import)
  // TODO: Replace with backend API integration
  // ============================================================

  /**
   * Save current localStorage state to a downloadable JSON file
   */
  saveMemory() {
    try {
      const data = this.storageManager.exportData();
      const blob = new Blob([data], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `symbiosis-memory-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      console.log('âœ… Memory saved to file');
      alert('Memory saved! ðŸ’¾\n\nYour workspace data has been downloaded.\nUse "Load Memory" to restore it in another browser.');
    } catch (error) {
      console.error('Failed to save memory:', error);
      alert('Failed to save memory: ' + error.message);
    }
  }

  /**
   * Load memory from a JSON file
   */
  loadMemory() {
    try {
      // Check if localStorage is available (Safari private browsing blocks it)
      try {
        localStorage.setItem('test', 'test');
        localStorage.removeItem('test');
      } catch (e) {
        alert('âš ï¸ localStorage is not available\n\nThis might be because:\n- You\'re in Private Browsing mode\n- Safari\'s tracking prevention is blocking it\n\nPlease try:\n1. Using normal (non-private) browsing\n2. Disabling "Prevent Cross-Site Tracking" in Safari settings');
        return;
      }

      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'application/json';

      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            console.log('ðŸ“‚ Reading file:', file.name);
            const data = JSON.parse(event.target.result);
            console.log('ðŸ“Š Parsed data:', data);

            // Validate data structure
            if (!data.user || !data.workspaces || !data.widgetInstances) {
              throw new Error('Invalid memory file format. Missing required fields: user, workspaces, or widgetInstances');
            }

            console.log('âœ… Data validation passed');

            // Confirm before overwriting
            if (!confirm('Load this memory?\n\nThis will replace your current workspace data.\nCurrent data will be lost unless you saved it first.')) {
              console.log('âŒ User cancelled load');
              return;
            }

            // Store in localStorage with error handling for Safari
            try {
              // Separate dock order from main data before storing
              const { dockOrder, ...mainData } = data;

              const jsonString = JSON.stringify(mainData);
              console.log('ðŸ’¾ Storing data in localStorage (size:', jsonString.length, 'bytes)');
              localStorage.setItem('symbiosis-data', jsonString);
              console.log('âœ… localStorage.setItem successful');

              // Store dock order separately if it exists (via StorageManager)
              if (dockOrder) {
                storageManager.saveDockOrder(dockOrder);
                console.log('âœ… Dock order restored');
              }

              // Verify it was stored
              const stored = localStorage.getItem('symbiosis-data');
              if (!stored) {
                throw new Error('localStorage.setItem succeeded but data is not retrievable');
              }
              console.log('âœ… Verified data is retrievable from localStorage');
            } catch (storageError) {
              console.error('âŒ localStorage error:', storageError);
              throw new Error('Failed to store data in localStorage: ' + storageError.message + '\n\nThis might be a Safari private browsing issue.');
            }

            console.log('âœ… Memory loaded from file successfully');
            alert('Memory loaded! ðŸ“‚\n\nReloading page to apply changes...');

            // Force a hard reload (Safari sometimes caches aggressively)
            window.location.href = window.location.href;
          } catch (error) {
            console.error('âŒ Failed to load memory:', error);
            alert('Failed to load memory:\n\n' + error.message + '\n\nCheck the browser console for details.');
          }
        };

        reader.onerror = (error) => {
          console.error('âŒ File read error:', error);
          alert('Failed to read file: ' + error.message);
        };

        reader.readAsText(file);
      };

      input.click();
    } catch (error) {
      console.error('âŒ Failed to initialize load:', error);
      alert('Failed to load memory: ' + error.message);
    }
  }

  /**
   * Clear all localStorage data (reset to initial state)
   */
  clearMemory() {
    try {
      if (!confirm('Clear all memory? ðŸ—‘ï¸\n\nThis will delete all workspaces, widgets, and dock configuration.\nThis action cannot be undone.\n\nMake sure you saved your data first if you want to keep it!')) {
        return;
      }

      localStorage.removeItem('symbiosis-data');
      storageManager.clearDockData();

      console.log('âœ… Memory cleared');
      alert('Memory cleared! ðŸ—‘ï¸\n\nReloading page to reset to initial state...');

      // Reload page to reset
      window.location.reload();
    } catch (error) {
      console.error('Failed to clear memory:', error);
      alert('Failed to clear memory: ' + error.message);
    }
  }

  loadWidgets() {
    this.errorBoundary.wrap(() => {
      const currentWorkspace = this.workspaceManager.getCurrentWorkspace();

      // IMPORTANT: Always set current workspace ID, even if no widgets yet
      this.widgetManager.setCurrentWorkspace(currentWorkspace.id);

      // Load widget instances from storage for current workspace
      const instances = this.storageManager.getWidgetInstancesForWorkspace(currentWorkspace.id);

      if (instances && instances.length > 0) {
        this.widgetManager.setWidgets(instances);

        instances.forEach(widget => {
          this.renderWidget(widget);
        });

        console.log('Loaded', instances.length, 'widgets from localStorage');
      }
    }, 'load-widgets', {
      fallback: () => {
        console.warn('Failed to load widgets, showing welcome message');
        this.showWelcome();
      }
    });
  }

  // Welcome Message
  hideWelcome() {
    const welcome = document.getElementById('welcome-message');
    if (welcome) {
      welcome.style.display = 'none';
    }
  }

  showWelcome() {
    const welcome = document.getElementById('welcome-message');
    if (welcome) {
      welcome.style.display = 'block';
    }
  }

  // Clear workspace (for testing)
  clearWorkspace() {
    if (confirm('Clear all widgets and reset workspace?')) {
      this.widgetManager.clearGrid();

      document.querySelectorAll('.widget-cell').forEach(cell => {
        const cellNumber = cell.dataset.cell;
        cell.classList.add('empty');
        cell.innerHTML = `<span style="color: #2563eb; font-weight: 600;">${cellNumber}</span>`;
      });

      this.workspaceManager.saveWorkspace();
      this.showWelcome();

      console.log('Workspace cleared');
    }
  }

  /**
   * Register workspace-level hotkeys
   * These are active when no app has focus
   */
  registerWorkspaceHotkeys() {
    // Workspace switching: Ctrl+1 through Ctrl+9
    for (let i = 1; i <= 9; i++) {
      this.hotkeyManager.registerWorkspaceHotkey(
        `Ctrl+${i}`,
        () => {
          const workspaces = this.workspaceManager.workspaces;
          if (i <= workspaces.length) {
            const workspace = workspaces[i - 1];
            this.workspaceManager.switchWorkspace(workspace.id);
            console.log(`Switched to workspace ${i}: ${workspace.name}`);
          }
        },
        `Switch to workspace ${i}`
      );
    }

    // Open widget drawer: Ctrl+N
    this.hotkeyManager.registerWorkspaceHotkey(
      'Ctrl+N',
      () => {
        this.drawerManager.open();
      },
      'Open widget drawer'
    );

    // Close app (ESC) - when app has focus, this will be handled by app-specific hotkey
    // But we register it here as fallback
    this.hotkeyManager.registerWorkspaceHotkey(
      'Escape',
      () => {
        // If any app is open, close it
        if (this.appUIController.activeAppInstanceId) {
          this.appUIController.closeApp(this.appUIController.activeAppInstanceId);
        }
      },
      'Close active app'
    );

    console.log('âœ… Workspace hotkeys registered (Ctrl+1-9, Ctrl+N, ESC)');
  }
}

// Initialize desktop when DOM is ready
let desktopManager;

document.addEventListener('DOMContentLoaded', () => {
  desktopManager = new DesktopManager();

  // Make available globally for debugging
  window.desktopManager = desktopManager;
  window.workspaceManager = desktopManager.workspaceManager;
  window.hotkeyManager = desktopManager.hotkeyManager;
  window.storageManager = desktopManager.storageManager;
  window.menuBarManager = desktopManager.menuBarManager;

  // Export functionality for saving data to file
  window.exportData = () => {
    const data = desktopManager.storageManager.exportData();
    console.log('%cðŸ“¦ Current Data State:', 'color: #2563eb; font-weight: bold; font-size: 14px');
    console.log('%cCopy this and paste it into temp-data-file.js:', 'color: #059669; font-weight: bold');
    console.log(data);
    return data;
  };

  console.log('Desktop manager available as window.desktopManager');
  console.log('Workspace manager available as window.workspaceManager');
  console.log('Hotkey manager available as window.hotkeyManager');
  console.log('Storage manager available as window.storageManager');
  console.log('Menu bar manager available as window.menuBarManager');
  console.log('');
  console.log('%cðŸ’¾ To export data:', 'color: #2563eb; font-weight: bold');
  console.log('  Run: exportData()');
  console.log('  Copy the output and paste into temp-data-file.js');

  // Initialize dock magnification effect
  initializeDockMagnification();
});

// Dock Magnification & Management
function initializeDockMagnification() {
  const dock = document.getElementById('desktop-dock');
  if (!dock) return;

  const BASE_SIZE = 64;
  const MAX_SCALE = 1.4;
  const INFLUENCE_RANGE = 120;
  const EXPANDED_PADDING = 22;

  let editMode = false;
  let longPressTimer = null;
  let sortable = null;

  // Initialize SortableJS
  function initSortable() {
    if (sortable) {
      sortable.destroy();
    }

    sortable = Sortable.create(dock, {
      animation: 200,
      easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
      ghostClass: 'dock-item-ghost',
      dragClass: 'dock-item-dragging',
      disabled: true, // Start disabled, enable in edit mode

      onEnd: (evt) => {
        if (evt.oldIndex !== evt.newIndex) {
          saveDockOrder();
        }
      }
    });
  }

  // Enter edit mode
  function enterEditMode() {
    editMode = true;
    dock.classList.add('dock-edit-mode');

    // Reset all transforms from magnification
    dock.querySelectorAll('.dock-item').forEach((item) => {
      item.style.transform = '';
      item.style.width = `${BASE_SIZE}px`;
      item.style.height = `${BASE_SIZE}px`;
    });

    // Reset dock padding
    dock.style.paddingTop = '16px';
    dock.style.paddingBottom = '16px';

    // Enable sortable
    if (sortable) {
      sortable.option('disabled', false);
    }

    // Add remove buttons to non-permanent items only
    dock.querySelectorAll('.dock-item').forEach(item => {
      const isPermanent = item.dataset.permanent === 'true';

      if (!isPermanent && !item.querySelector('.dock-remove-btn')) {
        const removeBtn = document.createElement('div');
        removeBtn.className = 'dock-remove-btn';
        removeBtn.innerHTML = 'Ã—';
        removeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          removeApp(item);
        });
        item.appendChild(removeBtn);
      }
    });
  }

  // Exit edit mode
  function exitEditMode() {
    editMode = false;
    dock.classList.remove('dock-edit-mode');

    // Disable sortable
    if (sortable) {
      sortable.option('disabled', true);
    }

    // Remove all remove buttons
    dock.querySelectorAll('.dock-remove-btn').forEach(btn => btn.remove());
  }

  // Remove an app from dock
  function removeApp(item) {
    if (confirm('Remove this app from the dock?')) {
      item.classList.add('dock-item-removing');
      setTimeout(() => {
        item.remove();
        saveDockOrder();
        exitEditMode();
      }, 300);
    }
  }

  // Save dock order to localStorage (via StorageManager)
  function saveDockOrder() {
    const order = Array.from(dock.querySelectorAll('.dock-item')).map(item =>
      item.dataset.app
    );
    storageManager.saveDockOrder(order);
  }

  // Setup long-press detection for edit mode
  dock.querySelectorAll('.dock-item').forEach(item => {
    const icon = item.querySelector('.dock-icon');

    icon.addEventListener('mousedown', () => {
      if (!editMode) {
        longPressTimer = setTimeout(() => {
          enterEditMode();
        }, 2000); // 2 seconds
      }
    });

    icon.addEventListener('mouseup', () => {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    });

    icon.addEventListener('mouseleave', () => {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    });
  });

  // Click outside to exit edit mode
  document.addEventListener('click', (e) => {
    if (editMode && !dock.contains(e.target)) {
      exitEditMode();
    }
  });

  // Magnification effect
  dock.addEventListener('mouseenter', () => {
    if (!editMode) {
      dock.style.paddingTop = `${EXPANDED_PADDING}px`;
      dock.style.paddingBottom = `${EXPANDED_PADDING}px`;
    }
  });

  dock.addEventListener('mousemove', (e) => {
    if (editMode) return; // Disable magnification in edit mode

    const mouseX = e.clientX;
    const dockItems = Array.from(dock.querySelectorAll('.dock-item'));

    dockItems.forEach((item) => {
      const itemRect = item.getBoundingClientRect();
      const itemCenterX = itemRect.left + itemRect.width / 2;
      const distance = Math.abs(mouseX - itemCenterX);

      let scale = 1;
      if (distance < INFLUENCE_RANGE) {
        const normalizedDistance = distance / INFLUENCE_RANGE;
        scale = 1 + (MAX_SCALE - 1) * (1 - normalizedDistance);
      }

      item.style.transform = `scale(${scale})`;
      item.style.width = `${BASE_SIZE}px`;
      item.style.height = `${BASE_SIZE * scale}px`;
    });
  });

  dock.addEventListener('mouseleave', () => {
    dock.style.paddingTop = '16px';
    dock.style.paddingBottom = '16px';

    dock.querySelectorAll('.dock-item').forEach((item) => {
      item.style.transform = 'scale(1)';
      item.style.width = `${BASE_SIZE}px`;
      item.style.height = `${BASE_SIZE}px`;
    });
  });

  // Dock drop handling is now managed by DockManager
  // (Removed duplicate drop handlers and addAppToDock function)

  // Setup long-press for a single item
  function setupLongPressForItem(dockItem) {
    if (dockItem.dataset.permanent === 'true') return;

    const icon = dockItem.querySelector('.dock-icon');
    if (!icon) return;

    icon.addEventListener('mousedown', () => {
      if (!editMode) {
        longPressTimer = setTimeout(() => {
          enterEditMode();
        }, 2000);
      }
    });

    icon.addEventListener('mouseup', () => {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    });

    icon.addEventListener('mouseleave', () => {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    });
  }

  // Restore dock order from localStorage (via StorageManager)
  function restoreDockOrder() {
    const savedOrder = storageManager.loadDockOrder();
    if (!savedOrder) return;

    try {
      const dockItems = Array.from(dock.querySelectorAll('.dock-item'));

      // Create a map of current items by app ID
      const itemMap = {};
      dockItems.forEach(item => {
        const appId = item.dataset.app;
        if (appId) {
          itemMap[appId] = item;
        }
      });

      // Reorder items according to saved order
      savedOrder.forEach(appId => {
        if (itemMap[appId]) {
          dock.appendChild(itemMap[appId]);
        }
      });

      console.log('âœ… Dock order restored from localStorage');
    } catch (error) {
      console.error('Failed to restore dock order:', error);
    }
  }

  // Initialize
  initSortable();
  restoreDockOrder();
}
